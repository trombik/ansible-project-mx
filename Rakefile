# Generated by `infrataster init`

require "English"
require "rake"
require "rspec/core/rake_task"
require "yaml"
require "net/ssh"
require "tempfile"
require "pathname"
require "highline/import"
require "vagrant/serverspec"
require "vagrant/ssh/config"
require "retries"
$LOAD_PATH.unshift(Pathname.new(File.dirname(__FILE__)) + "ruby" + "lib")
require "ansible_inventory"

def exec_and_abort_if_fail(cmd)
  status = system cmd
  warn "`#{cmd}` failed." unless $CHILD_STATUS.exitstatus.zero?
  abort unless $CHILD_STATUS.exitstatus.zero?
  status
end

def vagrant(args)
  Bundler.with_clean_env do
    exec_and_abort_if_fail "vagrant #{args}"
  end
end

def ansible_environment
  known_environment = %w[virtualbox staging prod]
  env = ENV["ANSIBLE_ENVIRONMENT"] ? ENV["ANSIBLE_ENVIRONMENT"] : "virtualbox"
  raise "unknown environment `#{env}`" unless known_environment.include?(env)
  env
end

def inventory_path
  "inventories/#{ansible_environment}"
end

def sudo_password
  ask("Enter sudo password: ") { |q| q.echo = false }
end

def sudo_password_required?(user)
  user != "root" && user != "vagrant" && user != "ec2-user"
end

def configure_sudo_password_for(user)
  ENV["SUDO_PASSWORD"] = sudo_password if
    sudo_password_required?(user) &&
    !ENV.key?("SUDO_PASSWORD")
end

def plan_path
  "terraform/plans/#{ansible_environment}"
end

def run_as_user(env)
  return ENV["ANSIBLE_USER"] if ENV["ANSIBLE_USER"]
  case env
  when "virtualbox"
    "vagrant"
  when "staging"
    "ec2-user"
  when "prod"
    ENV["USER"]
  end
end

puts "ANSIBLE_ENVIRONMENT: #{ansible_environment}"

desc "launch VMs"
task :up do
  case ansible_environment
  when "virtualbox"
    vagrant "up --no-provision"
  when "staging"
    sh "terraform apply #{plan_path}"

    # make sure the cache is up-to-date
    sh "#{inventory_path}/ec2.py --refresh-cache"

    # make sure all hosts are ready for ansible play
    retry_opts = {
      max_tries: 10, base_sleep_seconds: 10, max_sleep_seconds: 30
    }
    with_retries(retry_opts) do |_attempt_number|
      sh "ansible -i #{inventory_path} --ssh-common-args '-o \"UserKnownHostsFile /dev/null\" -o \"StrictHostKeyChecking no\"' --user 'ec2-user' -m ping all"
    end
  end
end

desc "destroy VMs"
task :clean do
  case ansible_environment
  when "virtualbox"
    vagrant "destroy -f"
  when "staging"
    sh "terraform destroy -force #{plan_path}"
  end
end

desc "vagrant provision"
task :provision do
  case ansible_environment
  when "virtualbox"
    vagrant "provision"
  when "staging"
    sh "ansible-playbook -i #{inventory_path} --ssh-common-args '-o \"UserKnownHostsFile /dev/null\" -o \"StrictHostKeyChecking no\"' --user 'ec2-user' playbooks/site.yml"
  end
end

desc "perform all tests"
task test: [
  "test:travis",
  :up,
  :provision,
  "test:serverspec:all",
  "test:integration:all"
] do
end

# rubocop:disable Metrics/BlockLength:
namespace :test do
  desc "Prepare"
  task :prepare do
    case ansible_environment
    when "virtualbox"
      vagrant "up"
      vagrant "provision"
    end
  end

  desc "Provision"
  task :provision do
    case ansible_environment
    when "virtualbox"
      vagrant "provision"
    else
      warn "unknown environment `#{ansible_environment}`"
      exit 1
    end
  end

  desc "Restart VMs"
  task :restart do
    case ansible_environment
    when "virtualbox"
      vagrant "reload --provision"
    else
      warn "unknown environment `#{ansible_environment}`"
      exit 1
    end
  end

  desc "Clean"
  task :clean do
    case ansible_environment
    when "virtualbox"
      begin
        # XXX use `true` until https://github.com/hashicorp/vagrant/issues/9137 is
        # fixed.
        vagrant "destroy -f || true"
      ensure
        sh "rm -f *.vdi"
      end
    else
      warn "unknown environment `#{ansible_environment}`"
      exit 1
    end
  end

  namespace "serverspec" do
    desc "Run serverspec on all hosts"
    task "all" do
      inventory = AnsibleInventory.new(inventory_path)
      inventory.all_groups.each do |g|
        next unless Dir.exist?("spec/serverspec/#{g}")
        inventory.all_hosts_in(g).each do |h|
          # XXX pass SUDO_PASSWORD to serverspec if the user is required to
          # type password
          configure_sudo_password_for(run_as_user(ansible_environment))
          puts "running serverspec for #{g} on #{h} as user `#{run_as_user(ansible_environment)}`"
          Vagrant::Serverspec.new(inventory_path).run(group: g, hostname: h)
        end
      end
    end
    groups = Dir.glob("sepc/serverspec/*").select { |d| d != "shared_examples" && File.directory?(d) }
    groups.each do |g|
      next unless Dir.exist?("spec/serverspec/#{g}")
      desc "Run serverspec for group `#{g}`"
      task g.to_sym do |_t|
        inventory.all_hosts_in(g).each do |h|
          configure_sudo_password_for(run_as_user(ansible_environment))
          puts "running serverspec for #{g} on #{h} as user `#{run_as_user(ansible_environment)}`"
          Vagrant::Serverspec.new(inventory_path).run(group: g, hostname: h)
        end
      end
    end
  end

  namespace "integration" do
    user = run_as_user(ansible_environment)
    directories = Pathname.glob("spec/integration/[0-9][0-9][0-9]_*")
    directories.each do |d|
      desc "run integration spec #{d.basename}"
      task d.basename.to_s do
        vault_password_file = ENV["ANSIBLE_VAULT_PASSWORD_FILE"]
        test_env = ansible_environment
        Bundler.with_clean_env do
          ENV["ANSIBLE_ENVIRONMENT"] = test_env
          ENV["ANSIBLE_VAULT_PASSWORD_FILE"] = vault_password_file
          configure_sudo_password_for(user)
          sh "bundle exec rspec #{d}/*_spec.rb"
        end
      end
    end
    desc "Run integration test"
    task :all do
      # XXX run `bundler exec rspec` in a clean environment.
      # the difference from running `rspec` in bundler environment is that:
      # when invoking `rspec` within `with_clean_env`, the forked process can
      # escape, or shellout, from the bundler environment.
      #
      # `rspec` is a different process. when you invoke `rspec` without
      # `with_clean_env`, the bundler in `rspec` process keeps a copy of
      # original environemnt and replace current environment with the copy when
      # inside of `with_clean_env`. but because, in this case, the copied
      # environment inherits the bundler environment of `rake`, the environment
      # the process replaced is still bundler environment.
      vault_password_file = ENV["ANSIBLE_VAULT_PASSWORD_FILE"]
      test_env = ansible_environment
      user = run_as_user(ansible_environment)
      Bundler.with_clean_env do
        ENV["ANSIBLE_ENVIRONMENT"] = test_env
        ENV["ANSIBLE_VAULT_PASSWORD_FILE"] = vault_password_file
        configure_sudo_password_for(user)
        sh "bundle exec rspec spec/integration/**/*_spec.rb"
      end
    end
  end

  namespace "travis" do
    task :rubocop do
      sh "rubocop --display-cop-names --display-style-guide --extra-details"
    end

    task :markdownlint do
      sh "node node_modules/markdownlint-cli/markdownlint.js ."
    end

    task :yamllint do
      sh "yamllint -c .yamllint.yml ."
    end

    task all: [:rubocop, :markdownlint, :yamllint]
  end
  desc "Run tests performed in Travis CI"
  task travis: ["travis:all"]
end
# rubocop:enable Metrics/BlockLength:
